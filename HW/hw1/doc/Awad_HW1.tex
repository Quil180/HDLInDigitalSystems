\documentclass[11pt, letterpaper]{article}

% Packages
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{float}
\usepackage{hyperref}
\usepackage{caption}

% Page Layout
\geometry{margin=1in}

% Code Listing Style
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{verilogstyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{blue},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                  
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                   
    tabsize=2,
    language=Verilog
}

\lstset{style=verilogstyle}

% Title Info
\title{HDL Design Homework: 4-Bit Adder Architectures}
\author{Yousef Awad \\ EEL 4783 - HDL in Digital Systems}
\date{\today}

\begin{document}

\maketitle

\section*{Part 1: Design Specifications}
Below is the synthesizable HDL code for the Ripple-Carry Adder (RCA), Carry-Lookahead Adder (CLA), and the associated testbench.

\subsection*{D. Full Adder}
\textbf{File: \texttt{full\_adder.sv}}
\lstinputlisting{../src/full_adder.sv}

\subsection*{B. Ripple-Carry Adder (RCA)}
\textbf{File: \texttt{rca.sv}}
\lstinputlisting{../src/rca.sv}

\subsection*{C. Carry-Lookahead Adder (CLA)}
\textbf{File: \texttt{cla.sv}}
\lstinputlisting{../src/cla.sv}

\pagebreak
\subsection*{D. Testbench}
\textbf{File: \texttt{testbench\_adders.sv}}
\lstinputlisting{../src/testbench_adders.sv}

\newpage
\section*{Part 2: Testbench \& Simulation}

\begin{figure}[H]
	\centering
	% REPLACE WITH YOUR ACTUAL FILE NAME
	\includegraphics[width=\textwidth]{simulation_fig1.jpg}
	\caption{\textbf{Functional Comparison.} The waveforms confirm that both RCA and CLA produce identical Sum and Carry-out values for all test vectors.}
	\label{fig:comparison}
\end{figure}

\begin{figure}[H]
	\centering
	% REPLACE WITH YOUR ACTUAL FILE NAME
	\includegraphics[width=\textwidth]{simulation_fig2.jpg}
	\caption{\textbf{Critical Path Zoom-In.} The timing detail reveals the ``ripple'' effect in the RCA carry chain ($C_1 \to C_2 \to C_3$), while the CLA output settles significantly faster.}
	\label{fig:zoom}
\end{figure}

\newpage
\section*{Part 3: Analysis \& Discussion}

\subsection*{1. Timing Comparison}
For test vector \#5 (Critical Path Test), the propagation delays were measured from the input change to stable $C_{out}$.
\begin{itemize}
	\item \textbf{RCA Delay:} $\approx$ 400 ps (approximate, see Fig 2)
	\item \textbf{CLA Delay:} Negligible / Instantaneous relative to RCA
\end{itemize}
\textbf{Explanation:} The Ripple-Carry Adder exhibits sequential propagation because the carry-out of bit $i$ ($C_{i+1}$) depends directly on the carry-in from the previous bit ($C_i$).
This creates a dependency chain where the signal must traverse every Full Adder physically.
In contrast, the CLA calculates all carry bits simultaneously using flattened logic equations based purely on inputs $A$, $B$, and $C_{in}$, eliminating the ``waiting'' period.

\subsection*{2. Circuit Explanation}
At the gate level, the RCA delay scales as $O(N)$ because the critical path flows through $N$ Full Adder blocks in series.
If a single Full Adder has a delay of $t_{FA}$, the total delay is $N \times t_{FA}$.
The CLA delay scales as $O(\log N)$ (or effectively $O(1)$ for fixed logic depths).
This is because the carry logic is expanded into a Sum-of-Products form.
For example, $C_4$ is calculated as:
\[ C_4 = G_3 + P_3G_2 + P_3P_2G_1 + P_3P_2P_1G_0 + P_3P_2P_1P_0C_{in} \]
This equation is realized with a 2-level AND-OR logic depth regardless of the bit position (limited only by the fan-in capability of the gates), allowing simultaneous calculation.

\subsection*{3. Area-Speed Tradeoff}
The CLA requires significantly more logic gates than the RCA.
\begin{itemize}
	\item \textbf{RCA:} Uses $\approx 5$ gates per bit.
	      Total for 4-bit $\approx 20$ gates. Linear area growth.
	\item \textbf{CLA:} Requires complex logic for the Generate/Propagate lookahead units.
	      The gate count grows cubically/exponentially depending on implementation details.
\end{itemize}
Designers might still choose RCA for wide adders (e.g., $>$16 bits) if the application is **low-power** or **area-constrained** and the adder is not on the critical timing path.
CLA is preferred strictly when minimizing delay is the highest priority.

\subsection*{4. Real-World Relevance}
Modern FPGAs (like Xilinx 7-Series or Ultrascale) contain dedicated hardware resources known as **Carry Chains** (e.g., CARRY4 or CARRY8 primitives).
These are hardened, high-speed silicon paths located adjacent to the LUTs.
This hardware optimization allows Ripple-Carry structures to operate at extremely high speeds, often mitigating the theoretical delay disadvantage of RCA and negating the need for complex soft-logic CLAs for standard integer addition.

\subsection*{Extra Credit: Synthesis Report Analysis}
Synthesis reports were generated for both designs to quantify the hardware cost.
The reports below compare the combinatorial area and leaf cell count for the 4-bit implementations.
\begin{table}[H]
	\centering
	\begin{tabular}{|l|c|c|c|}
		\hline
		\textbf{Metric}        & \textbf{RCA} & \textbf{CLA} & \textbf{Difference} \\
		\hline
		Combinational Area     & 94.00        & 98.00        & +4.2\%              \\
		Leaf Cell Count        & 54           & 57           & +3 Cells
		\\
		Sequential Cells (FFs) & 0            & 0            & 0                   \\
		\hline
	\end{tabular}
	\caption{\textbf{Synthesis Quality of Results (QoR) Comparison.} The CLA consumes slightly more area due to the additional lookahead logic gates.}
	\label{tab:synthesis}
\end{table}

\noindent \textbf{Analysis:}
The synthesis results confirm the theoretical area-speed tradeoff.
The RCA is smaller (Area: 94.00) because it uses a simple chain of full adders.
The CLA is larger (Area: 98.00) because of the extra logic required for the Generate/Propagate and Carry Lookahead units.
Both designs are purely combinational, resulting in zero sequential cells (Flip-Flops).

\subsubsection*{Synthesis Report Snippets}

\textbf{RCA Quality of Results (excerpt):}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, frame=single]
  Cell Count
  -----------------------------------
  Leaf Cell Count:                  54
  Combinational Cell Count:         54
  Sequential Cell Count:             0
  -----------------------------------

  Area
  -----------------------------------
  Combinational Area:       94.000000
  Buf/Inv Area:             38.000000
  Cell Area:                94.000000
\end{lstlisting}

\textbf{CLA Quality of Results (excerpt):}
\begin{lstlisting}[basicstyle=\ttfamily\scriptsize, frame=single]
  Cell Count
  -----------------------------------
  Leaf Cell Count:                  57
  Combinational Cell Count:         57
  Sequential Cell Count:             0
  -----------------------------------

  Area
  -----------------------------------
  Combinational Area:       98.000000
  Buf/Inv Area:             41.000000
  Cell Area:                98.000000
\end{lstlisting}

\end{document}
